connections:
  aws: aws_connection
desc: ''
name: foundational_security_dms
steps:
- desc: example description delete afterwards
  description: This control checks whether AWS DMS replication instances are public.
    To do this, it examines the value of the PubliclyAccessible field. A private replication
    instance has a private IP address that you cannot access outside of the replication
    network. A replication instance should have a private IP address when the source
    and target databases are in the same network. The network must also be connected
    to the replication instance's VPC using a VPN, AWS Direct Connect, or VPC peering.
    To learn more about public and private replication instances, see Public and private
    replication instances in the AWS Database Migration Service User Guide.
  text: '#1 AWS Database Migration Service replication instances should not be public'
- action: core.sql
  desc: Description
  id: S1
  inputs:
    sql: " \n select\n  -- Required Columns\n  arn as resource,\n  case\n    when\
      \ publicly_accessible then 'alarm'\n    else 'ok'\n  end status,\n  case\n \
      \   when publicly_accessible then title || ' publicly accessible.'\n    else\
      \ title || ' not publicly accessible.'\n  end reason,\n  -- Additional Dimensions\n\
      \  region,\n  account_id\nfrom\n  aws_dms_replication_instance;\n"
  name: Perform the query
- action: core.python
  desc: Description
  id: S2
  inputs:
    code: 'from dotmap import DotMap

      import json

      filtered_on_alarm = [x for x in context.steps.S1.output.rows if ( x[context.steps.S1.output.columns.index(''status'')]
      == ''alarm'' )]


      check = DotMap()


      check.isAlarm = len(filtered_on_alarm) > 0

      check.details = context.steps.S1.output.rows

      check.name = "#1 AWS Database Migration Service replication instances should
      not be public"

      check.severity = "critical"


      print(json.dumps(check.toDict()))'
  name: Format Result
- action: core.python
  desc: Description
  id: FormatResult
  inputs:
    code: "from dotmap import DotMap\nfrom datetime import date\nimport json\n\ntoday\
      \ = \"*\" + str(date.today()) +\"*\"\n\nmessage_blocks = []\nheader = {\"type\"\
      : \"header\", \"text\": {\"type\": \"plain_text\",\"text\": \":speaker:  foundational_security_dms\
      \  :speaker:\"}}\ncontext_section = {\"type\":\"context\",\"elements\":[{\"\
      text\": today+\" |  foundational_security_dms Check results \",\"type\":\"mrkdwn\"\
      }]}\n\nmessage_blocks.append(header)\nmessage_blocks.append(context_section)\n\
      \nstep_ids = ['S2']\nfor id in step_ids:\n  if context.steps[id].status == 'OK':\n\
      \    message_blocks.append({\"type\":\"divider\"})\n    \n    section = DotMap()\n\
      \    section.type = \"section\"\n    section.text = DotMap()\n    section.text.type\
      \ = \"mrkdwn\"\n    section.text.text = \"\"\n    if context.steps[id].output.isAlarm:\n\
      \      section.text.text +=  \":x: \"\n    else:\n       section.text.text +=\
      \  \":white_check_mark: \"\n    \n    section.text.text += context.steps[id].output.name[:82]\
      \ + \"\\n\"\n    \n\n    message_blocks.append(section.toDict().copy())\n\n\
      \  \nprint(json.dumps(message_blocks))"
  name: Format Final Result
- action: slack.SendMessage
  connectiuon:
    slack: slack_connection
  id: SendResult
  inputs:
    Blocks: '{{steps.FormatResult.output}}'
    Channel: jon-demo
    Text: ''
  name: Send report to clack channel
tags: []
type: Flow
