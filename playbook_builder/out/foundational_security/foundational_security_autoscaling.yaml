connections:
  aws: aws_connection
desc: 'This section contains recommendations for configuring Auto Scaling resources
  and options.

  '
inputs:
  send_notif:
    default: true
    display_name: Send Slack Notification
    required: true
    type: checkbox
name: foundational_security_autoscaling
outputs:
  S2: '{{steps.S2.output}}'
  check_name: foundational_security_autoscaling
  execution_url: '{{execution_url}}'
steps:
- desc: example description delete afterwards
  text: '# 1 Auto Scaling groups associated with a load balancer should use load balancer
    health checks'
- text: This control checks whether your Auto Scaling groups that are associated with
    a load balancer are using Elastic Load Balancing health checks. This ensures that
    the group can determine an instance's health based on additional tests provided
    by the load balancer. Using Elastic Load Balancing health checks can help support
    the availability of applications that use EC2 Auto Scaling groups.
- action: core.sql
  desc: Description
  id: S1
  inputs:
    sql: " \n select\n  -- Required Columns\n  autoscaling_group_arn as resource,\n\
      \  case\n    when load_balancer_names is null and target_group_arns is null\
      \ then 'alarm'\n    when health_check_type != 'ELB' then 'alarm'\n    else 'ok'\n\
      \  end as status,\n  case\n    when load_balancer_names is null and target_group_arns\
      \ is null then title || ' not associated with a load balancer.'\n    when health_check_type\
      \ != 'ELB' then title || ' does not use ELB health check.'\n    else title ||\
      \ ' uses ELB health check.'\n  end as reason,\n  -- Additional Dimensions\n\
      \  region,\n  account_id\nfrom\n  aws_ec2_autoscaling_group;\n"
  name: Perform the query
- action: core.python
  desc: Description
  id: S2
  inputs:
    code: 'from dotmap import DotMap

      import json

      filtered_on_alarm = [x for x in context.steps.S1.output.rows if ( x[context.steps.S1.output.columns.index(''status'')]
      == ''alarm'' )]


      check = DotMap()


      check.isAlarm = len(filtered_on_alarm) > 0

      check.details = context.steps.S1.output.rows

      check.name = "1 Auto Scaling groups associated with a load balancer should use
      load balancer health checks"

      check.severity = "low"


      print(json.dumps(check.toDict()))'
  name: Format Result
- desc: ' '
  text: '# Send Report to communication channel'
- action: core.python
  desc: Description
  id: FormatResult
  inputs:
    code: "from dotmap import DotMap\nfrom datetime import date\nimport json\n\ntoday\
      \ = \"*\" + str(date.today()) +\"*\"\n\nmessage_blocks = []\nexecution_url =\
      \ context.server_environment_url + \"/workspace/\" + context.workspace_id +\
      \ \"/playbooks/library/playbook?id=\" + context.playbook_id + \"&execution=\"\
      \ + context.execution_id \nheader = {\"type\": \"header\", \"text\": {\"type\"\
      : \"plain_text\",\"text\": \":speaker:  foundational_security_autoscaling  :speaker:\"\
      }}\ncontext_section = {\"type\":\"context\",\"elements\":[{\"text\": today+\"\
      \ |  foundational_security_autoscaling Check results \",\"type\":\"mrkdwn\"\
      }]}\nblink_execution = {\"type\":\"section\",\"text\":{\"text\": \":point_right:\
      \ <\" + execution_url + \"| *Full report available in Blink*>\" ,\"type\":\"\
      mrkdwn\"}}\nmessage_blocks.append(header)\nmessage_blocks.append(context_section)\n\
      message_blocks.append(blink_execution)\n\nstep_ids = ['S2']\nfor id in step_ids:\n\
      \  if context.steps[id].status == 'OK':\n    message_blocks.append({\"type\"\
      :\"divider\"})\n    \n    section = DotMap()\n    section.type = \"section\"\
      \n    section.text = DotMap()\n    section.text.type = \"mrkdwn\"\n    section.text.text\
      \ = \"\"\n    if context.steps[id].output.isAlarm:\n      section.text.text\
      \ +=  \":x: \"\n    else:\n       section.text.text +=  \":white_check_mark:\
      \ \"\n    \n    section.text.text += context.steps[id].output.name[:82] + \"\
      \\n\" if len(context.steps[id].output.name) > 82 else context.steps[id].output.name\n\
      \    \n\n    message_blocks.append(section.toDict().copy())\n\n  \nprint(json.dumps(message_blocks))"
  name: Format Final Result
- action: slack.SendMessage
  connections:
    slack: slack_connection
  id: SendResult
  inputs:
    Blocks: '{{steps.FormatResult.output}}'
    Channel: random
    Text: ''
  name: Send report to clack channel
  when: '{{inputs.send_notif}}'
tags:
- AWS
- Compliance
- autoscaling
type: Subflow.playbook
