connections:
  aws: aws_connection
desc: ''
name: foundational_security_s3
steps:
- desc: example description delete afterwards
  description: This control checks whether the following Amazon S3 public access block
    settings are configured at the account level
  text: '#1 S3 Block Public Access setting should be enabled'
- action: core.sql
  desc: Description
  id: S1
  inputs:
    sql: " \n select\n  -- Required Columns\n  'arn' || ':' || 'aws' || ':::' || account_id\
      \ as resource,\n  case\n    when block_public_acls\n      and block_public_policy\n\
      \      and ignore_public_acls\n      and restrict_public_buckets\n      then\
      \ 'ok'\n    else 'alarm'\n  end as status,\n  case\n    when block_public_acls\n\
      \      and block_public_policy\n      and ignore_public_acls\n      and restrict_public_buckets\n\
      \      then 'Account level public access blocks enabled.'\n    else 'Account\
      \ level public access not enabled for: ' ||\n      concat_ws(', ',\n       \
      \ case when not (block_public_acls ) then 'block_public_acls' end,\n       \
      \ case when not (block_public_policy) then 'block_public_policy' end,\n    \
      \    case when not (ignore_public_acls ) then 'ignore_public_acls' end,\n  \
      \      case when not (restrict_public_buckets) then 'restrict_public_buckets'\
      \ end\n      ) || '.'\n  end as reason,\n  -- Additional Dimensions\n  account_id\n\
      from\n  aws_s3_account_settings;"
  name: Perform the query
- action: core.python
  desc: Description
  id: S2
  inputs:
    code: 'from dotmap import DotMap

      import json

      filtered_on_alarm = [x for x in context.steps.S1.output.rows if ( x[context.steps.S1.output.columns.index(''status'')]
      == ''alarm'' )]


      check = DotMap()


      check.isAlarm = len(filtered_on_alarm) > 0

      check.details = context.steps.S1.output.rows

      check.name = "#1 S3 Block Public Access setting should be enabled"

      check.severity = "medium"


      print(json.dumps(check.toDict()))'
  name: Format Result
- desc: example description delete afterwards
  description: This control checks whether your S3 buckets allow public read access.
    It evaluates the Block Public Access settings, the bucket policy, and the bucket
    access control list (ACL).
  text: '#2 S3 buckets should prohibit public read access'
- action: core.sql
  desc: Description
  id: S3
  inputs:
    sql: " \n with data as (\n  select\n    distinct name\n  from\n    aws_s3_bucket,\n\
      \    json_each(acl, '$.Grants') as grants\n  where\n    json_extract(grants.value,'$.Grantee.URI')\
      \ = '\"http://acs.amazonaws.com/groups/global/AllUsers\"'\n    and (\n     \
      \ json_extract(grants.value,'$.Permission') = '\"FULL_CONTROL\"'\n      or json_extract(grants.value,'$.Permission')\
      \ = '\"READ_ACP\"'\n    )\n  )\nselect\n  -- Required Columns\n  b.arn as resource,\n\
      \  case\n    when d.name is null then 'ok'\n    else 'alarm'\n  end status,\n\
      \  case\n    when d.name is null then b.title || ' not publicly readable.'\n\
      \    else b.title || ' publicly readable.'\n  end reason,\n  -- Additional Dimensions\n\
      \  b.region,\n  b.account_id\nfrom\n  aws_s3_bucket as b\n  left join data as\
      \ d on b.name = d.name;"
  name: Perform the query
- action: core.python
  desc: Description
  id: S4
  inputs:
    code: 'from dotmap import DotMap

      import json

      filtered_on_alarm = [x for x in context.steps.S3.output.rows if ( x[context.steps.S3.output.columns.index(''status'')]
      == ''alarm'' )]


      check = DotMap()


      check.isAlarm = len(filtered_on_alarm) > 0

      check.details = context.steps.S3.output.rows

      check.name = "#2 S3 buckets should prohibit public read access"

      check.severity = "critical"


      print(json.dumps(check.toDict()))'
  name: Format Result
- desc: example description delete afterwards
  description: This control checks whether your S3 buckets allow public write access.
    It evaluates the block public access settings, the bucket policy, and the bucket
    access control list (ACL).
  text: '#3 S3 buckets should prohibit public write access'
- action: core.sql
  desc: Description
  id: S5
  inputs:
    sql: " \n with data as (\n  select\n    distinct name\n  from\n    aws_s3_bucket,\n\
      \    json_each(acl, '$.Grants') as grants\n  where\n    json_extract(grants.value,'$.Grantee.URI')\
      \ = '\"http://acs.amazonaws.com/groups/global/AllUsers\"'\n    and (\n     \
      \ json_extract(grants.value,'$.Permission') = '\"FULL_CONTROL\"'\n      or json_extract(grants.value,'$.Permission')\
      \ = '\"WRITE_ACP\"'\n    )\n  )\nselect\n  -- Required Columns\n  b.arn as resource,\n\
      \  case\n    when d.name is null then 'ok'\n    else 'alarm'\n  end status,\n\
      \  case\n    when d.name is null then b.title || ' not publicly writable.'\n\
      \    else b.title || ' publicly writable.'\n  end reason,\n  -- Additional Dimensions\n\
      \  b.region,\n  b.account_id\nfrom\n  aws_s3_bucket as b\n  left join data as\
      \ d on b.name = d.name;"
  name: Perform the query
- action: core.python
  desc: Description
  id: S6
  inputs:
    code: 'from dotmap import DotMap

      import json

      filtered_on_alarm = [x for x in context.steps.S5.output.rows if ( x[context.steps.S5.output.columns.index(''status'')]
      == ''alarm'' )]


      check = DotMap()


      check.isAlarm = len(filtered_on_alarm) > 0

      check.details = context.steps.S5.output.rows

      check.name = "#3 S3 buckets should prohibit public write access"

      check.severity = "critical"


      print(json.dumps(check.toDict()))'
  name: Format Result
- desc: example description delete afterwards
  description: This control checks that your S3 bucket either has Amazon S3 default
    encryption enabled or that the S3 bucket policy explicitly denies put-object requests
    without server-side encryption.
  text: '#4 S3 buckets should have server-side encryption enabled'
- action: core.sql
  desc: Description
  id: S7
  inputs:
    sql: " \n select\n  -- Required Columns\n  arn as resource,\n  case\n    when\
      \ server_side_encryption_configuration is not null then 'ok'\n    else 'alarm'\n\
      \  end status,\n  case\n    when server_side_encryption_configuration is not\
      \ null then name || ' default encryption enabled.'\n    else name || ' default\
      \ encryption disabled.'\n  end reason,\n  -- Additional Dimensions\n  region,\n\
      \  account_id\nfrom\n  aws_s3_bucket"
  name: Perform the query
- action: core.python
  desc: Description
  id: S8
  inputs:
    code: 'from dotmap import DotMap

      import json

      filtered_on_alarm = [x for x in context.steps.S7.output.rows if ( x[context.steps.S7.output.columns.index(''status'')]
      == ''alarm'' )]


      check = DotMap()


      check.isAlarm = len(filtered_on_alarm) > 0

      check.details = context.steps.S7.output.rows

      check.name = "#4 S3 buckets should have server-side encryption enabled"

      check.severity = "medium"


      print(json.dumps(check.toDict()))'
  name: Format Result
- desc: example description delete afterwards
  description: 'This control checks whether S3 buckets have policies that require
    requests to use Secure Socket Layer (SSL). S3 buckets should have policies that
    require all requests (Action: S3:*)to only accept transmission of data over HTTPS
    in the S3 resource policy, indicated by the condition key aws:SecureTransport.'
  text: '#5 S3 buckets should require requests to use Secure Socket Layer'
- action: core.sql
  desc: Description
  id: S9
  inputs:
    sql: " \n with ssl_ok as (\n  select\n    distinct name,\n    arn,\n    'ok' as\
      \ status\n  from\n    aws_s3_bucket,\n    json_each(policy_std, '$.Statement')\
      \ as s,\n    json_each(s.value, '$.Principal.AWS') as p,\n    json_each(s.value,\
      \ '$.Action') as a,\n    json_each(s.value, '$.Resource') as r,\n    json_each(\n\
      \      s.value, '$.Condition.Bool.aws:securetransport\n    ') as ssl\n  where\n\
      \    p.value = '*'\n    and json_extract(s.value,'$.Effect') = 'Deny'\n    and\
      \ cast(ssl.value as bool) = false\n)\nselect\n  -- Required Columns\n  b.arn\
      \ as resource,\n  case\n    when ok.status = 'ok' then 'ok'\n    else 'alarm'\n\
      \  end status,\n  case\n    when ok.status = 'ok' then b.name || ' bucket policy\
      \ enforces HTTPS.'\n    else b.name || ' bucket policy does not enforce HTTPS.'\n\
      \  end reason,\n  -- Additional Dimensions\n  b.region,\n  b.account_id\nfrom\n\
      \  aws_s3_bucket as b\n  left join ssl_ok as ok on ok.name = b.name;"
  name: Perform the query
- action: core.python
  desc: Description
  id: S10
  inputs:
    code: 'from dotmap import DotMap

      import json

      filtered_on_alarm = [x for x in context.steps.S9.output.rows if ( x[context.steps.S9.output.columns.index(''status'')]
      == ''alarm'' )]


      check = DotMap()


      check.isAlarm = len(filtered_on_alarm) > 0

      check.details = context.steps.S9.output.rows

      check.name = "#5 S3 buckets should require requests to use Secure Socket Layer"

      check.severity = "medium"


      print(json.dumps(check.toDict()))'
  name: Format Result
- desc: example description delete afterwards
  text: '#6 Amazon S3 permissions granted to other AWS accounts in bucket policies
    should be restricted - Not implemented'
- action: core.sql
  desc: Description
  id: S11
  inputs:
    sql: Select * from true
  name: Perform the query
  when: 'False'
- action: core.python
  desc: Description
  id: S12
  inputs:
    code: 'from dotmap import DotMap

      import json

      filtered_on_alarm = [x for x in context.steps.S11.output.rows if ( x[context.steps.S11.output.columns.index(''status'')]
      == ''alarm'' )]


      check = DotMap()


      check.isAlarm = len(filtered_on_alarm) > 0

      check.details = context.steps.S11.output.rows

      check.name = "#6 Amazon S3 permissions granted to other AWS accounts in bucket
      policies should be restricted - Not implemented"

      check.severity = "high"


      print(json.dumps(check.toDict()))'
  name: Format Result
  when: 'False'
- action: core.python
  desc: Description
  id: FormatResult
  inputs:
    code: "from dotmap import DotMap\nfrom datetime import date\nimport json\n\ntoday\
      \ = \"*\" + str(date.today()) +\"*\"\n\nmessage_blocks = []\nheader = {\"type\"\
      : \"header\", \"text\": {\"type\": \"plain_text\",\"text\": \":speaker:  foundational_security_s3\
      \  :speaker:\"}}\ncontext_section = {\"type\":\"context\",\"elements\":[{\"\
      text\": today+\" |  foundational_security_s3 Check results \",\"type\":\"mrkdwn\"\
      }]}\n\nmessage_blocks.append(header)\nmessage_blocks.append(context_section)\n\
      \nstep_ids = ['S2', 'S4', 'S6', 'S8', 'S10', 'S12']\nfor id in step_ids:\n \
      \ if context.steps[id].status == 'OK':\n    message_blocks.append({\"type\"\
      :\"divider\"})\n    \n    section = DotMap()\n    section.type = \"section\"\
      \n    section.text = DotMap()\n    section.text.type = \"mrkdwn\"\n    section.text.text\
      \ = \"\"\n    if context.steps[id].output.isAlarm:\n      section.text.text\
      \ +=  \":x: \"\n    else:\n       section.text.text +=  \":white_check_mark:\
      \ \"\n    \n    section.text.text += context.steps[id].output.name[:82] + \"\
      \\n\"\n    \n\n    message_blocks.append(section.toDict().copy())\n\n  \nprint(json.dumps(message_blocks))"
  name: Format Final Result
- action: slack.SendMessage
  connectiuon:
    slack: slack_connection
  id: SendResult
  inputs:
    Blocks: '{{steps.FormatResult.output}}'
    Channel: demo
    Text: ''
  name: Send report to clack channel
tags: []
type: Flow
