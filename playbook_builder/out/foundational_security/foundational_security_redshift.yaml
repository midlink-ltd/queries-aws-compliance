connections:
  aws: aws_connection
desc: This section contains recommendations for configuring AWS Redshift resources
  and options.
inputs:
  send_notif:
    default: true
    display_name: Send Slack Notification
    required: true
    type: checkbox
name: foundational_security_redshift
outputs:
  S10: '{{steps.S10.output}}'
  S2: '{{steps.S2.output}}'
  S4: '{{steps.S4.output}}'
  S6: '{{steps.S6.output}}'
  S8: '{{steps.S8.output}}'
  check_name: foundational_security_redshift
  execution_url: '{{execution_url}}'
steps:
- desc: example description delete afterwards
  text: '# 1 Amazon Redshift clusters should prohibit public access'
- text: This control checks whether Amazon Redshift clusters are publicly accessible.
    It evaluates the PubliclyAccessible field in the cluster configuration item. The
    PubliclyAccessible attribute of the Amazon Redshift cluster configuration indicates
    whether the cluster is publicly accessible. When the cluster is configured with
    PubliclyAccessible set to true, it is an Internet-facing instance that has a publicly
    resolvable DNS name, which resolves to a public IP address. When the cluster is
    not publicly accessible, it is an internal instance with a DNS name that resolves
    to a private IP address. Unless you intend for your cluster to be publicly accessible,
    the cluster should not be configured with PubliclyAccessible set to true.
- action: core.sql
  desc: Description
  id: S1
  inputs:
    sql: " \n select\n  -- Required Columns\n  cluster_namespace_arn as resource,\n\
      \  case\n    when publicly_accessible then 'alarm'\n    else 'ok'\n  end status,\n\
      \  case\n    when publicly_accessible then title || ' publicly accessible.'\n\
      \    else title || ' not publicly accessible.'\n  end reason,\n  -- Additional\
      \ Dimensions\n  region,\n  account_id\nfrom\n  aws_redshift_cluster;\n"
  name: Perform the query
- action: core.python
  desc: Description
  id: S2
  inputs:
    code: 'from dotmap import DotMap

      import json

      filtered_on_alarm = [x for x in context.steps.S1.output.rows if ( x[context.steps.S1.output.columns.index(''status'')]
      == ''alarm'' )]


      check = DotMap()


      check.isAlarm = len(filtered_on_alarm) > 0

      check.details = context.steps.S1.output.rows

      check.name = "1 Amazon Redshift clusters should prohibit public access"

      check.severity = "critical"


      print(json.dumps(check.toDict()))'
  name: Format Result
- desc: example description delete afterwards
  text: '# 2 Connections to Amazon Redshift clusters should be encrypted in transit'
- text: This control checks whether connections to Amazon Redshift clusters are required
    to use encryption in transit. The check fails if the Amazon Redshift cluster parameter
    require_SSL is not set to 1. TLS can be used to help prevent potential attackers
    from using person-in-the-middle or similar attacks to eavesdrop on or manipulate
    network traffic. Only encrypted connections over TLS should be allowed. Encrypting
    data in transit can affect performance. You should test your application with
    this feature to understand the performance profile and the impact of TLS.
- action: core.sql
  desc: Description
  id: S3
  inputs:
    sql: " \n with pg_with_ssl as (\n select\n  name as pg_name,\n  json_extract(p.value,'$.ParameterName')\
      \ as parameter_name,\n  json_extract(p.value,'$.ParameterValue') as parameter_value\n\
      from\n  aws_redshift_parameter_group,\n  json_each(parameters) as p\nwhere\n\
      \  json_extract(p.value,'$.ParameterName') = 'require_ssl'\n  and json_extract(p.value,'$.ParameterValue')\
      \ = 'true'\n)\nselect\n  -- Required Columns\n  'arn:aws:redshift:' || region\
      \ || ':' || account_id || ':' || 'cluster' || ':' || cluster_identifier as resource,\n\
      \  case\n    when json_extract(cpg.value,'$.ParameterGroupName') in (select\
      \ pg_name from pg_with_ssl ) then 'ok'\n    else 'alarm'\n  end as status,\n\
      \  case\n    when json_extract(cpg.value,'$.ParameterGroupName') in (select\
      \ pg_name from pg_with_ssl ) then title || ' encryption in transit enabled.'\n\
      \    else title || ' encryption in transit disabled.'\n  end as reason,\n  --\
      \ Additional Dimensions\n  region,\n  account_id\nfrom\n  aws_redshift_cluster,\n\
      \  json_each(cluster_parameter_groups) as cpg;"
  name: Perform the query
- action: core.python
  desc: Description
  id: S4
  inputs:
    code: 'from dotmap import DotMap

      import json

      filtered_on_alarm = [x for x in context.steps.S3.output.rows if ( x[context.steps.S3.output.columns.index(''status'')]
      == ''alarm'' )]


      check = DotMap()


      check.isAlarm = len(filtered_on_alarm) > 0

      check.details = context.steps.S3.output.rows

      check.name = "2 Connections to Amazon Redshift clusters should be encrypted
      in transit"

      check.severity = "medium"


      print(json.dumps(check.toDict()))'
  name: Format Result
- desc: example description delete afterwards
  text: '# 3 Amazon Redshift clusters should have automatic snapshots enabled'
- text: This control checks whether Amazon Redshift clusters have automated snapshots
    enabled. It also checks whether the snapshot retention period is greater than
    or equal to seven.
- action: core.sql
  desc: Description
  id: S5
  inputs:
    sql: " \n select\n  -- Required Columns\n  'arn:aws:redshift:' || region || ':'\
      \ || account_id || ':' || 'cluster' || ':' || cluster_identifier as resource,\n\
      \  case\n    when automated_snapshot_retention_period >= 7 then 'ok'\n    else\
      \ 'alarm'\n  end as status,\n  case\n    when automated_snapshot_retention_period\
      \ >= 7 then title || ' automatic snapshots enabled with retention period greater\
      \ than equals 7 days.'\n    else title || ' automatic snapshots not enabled\
      \ with retention period greater than equals 7 days.'\n  end as reason,\n  --\
      \ Additional Dimensions\n  region,\n  account_id\nfrom\n  aws_redshift_cluster;"
  name: Perform the query
- action: core.python
  desc: Description
  id: S6
  inputs:
    code: 'from dotmap import DotMap

      import json

      filtered_on_alarm = [x for x in context.steps.S5.output.rows if ( x[context.steps.S5.output.columns.index(''status'')]
      == ''alarm'' )]


      check = DotMap()


      check.isAlarm = len(filtered_on_alarm) > 0

      check.details = context.steps.S5.output.rows

      check.name = "3 Amazon Redshift clusters should have automatic snapshots enabled"

      check.severity = "medium"


      print(json.dumps(check.toDict()))'
  name: Format Result
- desc: example description delete afterwards
  text: '# 6 Amazon Redshift should have automatic upgrades to major versions enabled'
- text: This control checks whether automatic major version upgrades are enabled for
    the Amazon Redshift cluster.
- action: core.sql
  desc: Description
  id: S7
  inputs:
    sql: " \n select\n  -- Required Columns\n  'arn:aws:redshift:' || region || ':'\
      \ || account_id || ':' || 'cluster' || ':' || cluster_identifier as resource,\n\
      \  case\n    when allow_version_upgrade then 'ok'\n    else 'alarm'\n  end as\
      \ status,\n  case\n    when allow_version_upgrade then title || ' automatic\
      \ upgrades to major versions enabled.'\n    else title || ' automatic upgrades\
      \ to major versions disabled.'\n  end as reason,\n  -- Additional Dimensions\n\
      \  region,\n  account_id\nfrom\n  aws_redshift_cluster;"
  name: Perform the query
- action: core.python
  desc: Description
  id: S8
  inputs:
    code: 'from dotmap import DotMap

      import json

      filtered_on_alarm = [x for x in context.steps.S7.output.rows if ( x[context.steps.S7.output.columns.index(''status'')]
      == ''alarm'' )]


      check = DotMap()


      check.isAlarm = len(filtered_on_alarm) > 0

      check.details = context.steps.S7.output.rows

      check.name = "6 Amazon Redshift should have automatic upgrades to major versions
      enabled"

      check.severity = "medium"


      print(json.dumps(check.toDict()))'
  name: Format Result
- desc: example description delete afterwards
  text: '# 7 Amazon Redshift clusters should use enhanced VPC routing'
- text: This control checks whether an Amazon Redshift cluster has EnhancedVpcRouting
    enabled.
- action: core.sql
  desc: Description
  id: S9
  inputs:
    sql: " \n select\n  -- Required Columns\n  'arn:aws:redshift:' || region || ':'\
      \ || account_id || ':' || 'cluster' || ':' || cluster_identifier as resource,\n\
      \  case\n    when enhanced_vpc_routing then 'ok'\n    else 'alarm'\n  end as\
      \ status,\n  case\n    when enhanced_vpc_routing then title || ' enhanced VPC\
      \ routing enabled.'\n    else title || ' enhanced VPC routing disabled.'\n \
      \ end as reason,\n  -- Additional Dimensions\n  region,\n  account_id\nfrom\n\
      \  aws_redshift_cluster;"
  name: Perform the query
- action: core.python
  desc: Description
  id: S10
  inputs:
    code: 'from dotmap import DotMap

      import json

      filtered_on_alarm = [x for x in context.steps.S9.output.rows if ( x[context.steps.S9.output.columns.index(''status'')]
      == ''alarm'' )]


      check = DotMap()


      check.isAlarm = len(filtered_on_alarm) > 0

      check.details = context.steps.S9.output.rows

      check.name = "7 Amazon Redshift clusters should use enhanced VPC routing"

      check.severity = "high"


      print(json.dumps(check.toDict()))'
  name: Format Result
- desc: ' '
  text: '# Send Report to communication channel'
- action: core.python
  desc: Description
  id: FormatResult
  inputs:
    code: "from dotmap import DotMap\nfrom datetime import date\nimport json\n\ntoday\
      \ = \"*\" + str(date.today()) +\"*\"\n\nmessage_blocks = []\nexecution_url =\
      \ context.server_environment_url + \"/workspace/\" + context.workspace_id +\
      \ \"/playbooks/library/playbook?id=\" + context.playbook_id + \"&execution=\"\
      \ + context.execution_id \nheader = {\"type\": \"header\", \"text\": {\"type\"\
      : \"plain_text\",\"text\": \":speaker:  foundational_security_redshift  :speaker:\"\
      }}\ncontext_section = {\"type\":\"context\",\"elements\":[{\"text\": today+\"\
      \ |  foundational_security_redshift Check results \",\"type\":\"mrkdwn\"}]}\n\
      blink_execution = {\"type\":\"section\",\"text\":{\"text\": \":point_right:\
      \ <\" + execution_url + \"| *Full report available in Blink*>\" ,\"type\":\"\
      mrkdwn\"}}\nmessage_blocks.append(header)\nmessage_blocks.append(context_section)\n\
      message_blocks.append(blink_execution)\n\nstep_ids = ['S2', 'S4', 'S6', 'S8',\
      \ 'S10']\nfor id in step_ids:\n  if context.steps[id].status == 'OK':\n    message_blocks.append({\"\
      type\":\"divider\"})\n    \n    section = DotMap()\n    section.type = \"section\"\
      \n    section.text = DotMap()\n    section.text.type = \"mrkdwn\"\n    section.text.text\
      \ = \"\"\n    if context.steps[id].output.isAlarm:\n      section.text.text\
      \ +=  \":x: \"\n    else:\n       section.text.text +=  \":white_check_mark:\
      \ \"\n    \n    section.text.text += context.steps[id].output.name[:82] + \"\
      \\n\" if len(context.steps[id].output.name) > 82 else context.steps[id].output.name\n\
      \    \n\n    message_blocks.append(section.toDict().copy())\n\n  \nprint(json.dumps(message_blocks))"
  name: Format Final Result
- action: slack.SendMessage
  connections:
    slack: slack_connection
  id: SendResult
  inputs:
    Blocks: '{{steps.FormatResult.output}}'
    Channel: random
    Text: ''
  name: Send report to clack channel
  when: '{{inputs.send_notif}}'
tags:
- AWS
- Compliance
- redshift
type: Subflow.playbook
