connections:
  aws: aws_connection
desc: ''
name: foundational_security_dynamodb
steps:
- desc: example description delete afterwards
  text: '#1 DynamoDB tables should automatically scale capacity with demand - Not
    implemented'
- action: core.sql
  desc: Description
  id: S1
  inputs:
    sql: Select * from true
  name: Perform the query
  when: 'False'
- action: core.python
  desc: Description
  id: S2
  inputs:
    code: 'from dotmap import DotMap

      import json

      filtered_on_alarm = [x for x in context.steps.S1.output.rows if ( x[context.steps.S1.output.columns.index(''status'')]
      == ''alarm'' )]


      check = DotMap()


      check.isAlarm = len(filtered_on_alarm) > 0

      check.details = context.steps.S1.output.rows

      check.name = "#1 DynamoDB tables should automatically scale capacity with demand
      - Not implemented"

      check.severity = "medium"


      print(json.dumps(check.toDict()))'
  name: Format Result
  when: 'False'
- desc: example description delete afterwards
  text: '#2 DynamoDB tables should have point-in-time recovery enabled - Not implemented'
- action: core.sql
  desc: Description
  id: S3
  inputs:
    sql: Select * from true
  name: Perform the query
  when: 'False'
- action: core.python
  desc: Description
  id: S4
  inputs:
    code: 'from dotmap import DotMap

      import json

      filtered_on_alarm = [x for x in context.steps.S3.output.rows if ( x[context.steps.S3.output.columns.index(''status'')]
      == ''alarm'' )]


      check = DotMap()


      check.isAlarm = len(filtered_on_alarm) > 0

      check.details = context.steps.S3.output.rows

      check.name = "#2 DynamoDB tables should have point-in-time recovery enabled
      - Not implemented"

      check.severity = "medium"


      print(json.dumps(check.toDict()))'
  name: Format Result
  when: 'False'
- desc: example description delete afterwards
  description: This control checks whether a DAX cluster is encrypted at rest. Encrypting
    data at rest reduces the risk of data stored on disk being accessed by a user
    not authenticated to AWS. The encryption adds another set of access controls to
    limit the ability of unauthorized users to access to the data. For example, API
    permissions are required to decrypt the data before it can be read.
  text: '#3 DynamoDB Accelerator (DAX) clusters should be encrypted at rest'
- action: core.sql
  desc: Description
  id: S5
  inputs:
    sql: " \n select\n  -- Required Columns\n  arn as resource,\n  case\n    when\
      \ json_extract(sse_description,'$.Status') = 'ENABLED' then 'ok'\n    else 'alarm'\n\
      \  end as status,\n  case\n    when json_extract(sse_description,'$.Status')\
      \ = 'ENABLED' then title || ' encryption at rest enabled.'\n    else title ||\
      \ ' encryption at rest not enabled.'\n  end as reason,\n  -- Additional Dimensions\n\
      \  region,\n  account_id\nfrom\n  aws_dax_cluster;"
  name: Perform the query
- action: core.python
  desc: Description
  id: S6
  inputs:
    code: 'from dotmap import DotMap

      import json

      filtered_on_alarm = [x for x in context.steps.S5.output.rows if ( x[context.steps.S5.output.columns.index(''status'')]
      == ''alarm'' )]


      check = DotMap()


      check.isAlarm = len(filtered_on_alarm) > 0

      check.details = context.steps.S5.output.rows

      check.name = "#3 DynamoDB Accelerator (DAX) clusters should be encrypted at
      rest"

      check.severity = "medium"


      print(json.dumps(check.toDict()))'
  name: Format Result
- action: core.python
  desc: Description
  id: FormatResult
  inputs:
    code: "from dotmap import DotMap\nfrom datetime import date\nimport json\n\ntoday\
      \ = \"*\" + str(date.today()) +\"*\"\n\nmessage_blocks = []\nheader = {\"type\"\
      : \"header\", \"text\": {\"type\": \"plain_text\",\"text\": \":speaker:  foundational_security_dynamodb\
      \  :speaker:\"}}\ncontext_section = {\"type\":\"context\",\"elements\":[{\"\
      text\": today+\" |  foundational_security_dynamodb Check results \",\"type\"\
      :\"mrkdwn\"}]}\n\nmessage_blocks.append(header)\nmessage_blocks.append(context_section)\n\
      \nstep_ids = ['S2', 'S4', 'S6']\nfor id in step_ids:\n  if context.steps[id].status\
      \ == 'OK':\n    message_blocks.append({\"type\":\"divider\"})\n    \n    section\
      \ = DotMap()\n    section.type = \"section\"\n    section.text = DotMap()\n\
      \    section.text.type = \"mrkdwn\"\n    section.text.text = \"\"\n    if context.steps[id].output.isAlarm:\n\
      \      section.text.text +=  \":x: \"\n    else:\n       section.text.text +=\
      \  \":white_check_mark: \"\n    \n    section.text.text += context.steps[id].output.name[:82]\
      \ + \"\\n\"\n    \n\n    message_blocks.append(section.toDict().copy())\n\n\
      \  \nprint(json.dumps(message_blocks))"
  name: Format Final Result
- action: slack.SendMessage
  connectiuon:
    slack: slack_connection
  id: SendResult
  inputs:
    Blocks: '{{steps.FormatResult.output}}'
    Channel: jon-demo
    Text: ''
  name: Send report to clack channel
tags: []
type: Flow
