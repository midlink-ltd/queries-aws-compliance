connections:
  aws: aws_connection
desc: 'This section contains recommendations for configuring EC2 resources and options.

  '
inputs:
  send_notif:
    default: true
    display_name: Send Slack Notification
    required: true
    type: checkbox
name: pci_v321_ec2
outputs:
  S10: '{{steps.S10.output}}'
  S12: '{{steps.S12.output}}'
  S2: '{{steps.S2.output}}'
  S4: '{{steps.S4.output}}'
  S6: '{{steps.S6.output}}'
  S8: '{{steps.S8.output}}'
  check_name: pci_v321_ec2
  execution_url: '{{execution_url}}'
steps:
- desc: example description delete afterwards
  text: '#1 Amazon EBS snapshots should not be publicly restorable - Not implemented'
- text: "This control checks whether Amazon Elastic Block Store snapshots are not\
    \ publicly restorable by everyone, which makes them public. Amazon EBS snapshots\
    \ should not be publicly restorable by everyone unless you explicitly allow it,\
    \ to avoid accidental exposure of your company\u2019s sensitive data."
- action: core.sql
  desc: Description
  id: S1
  inputs:
    sql: Select * from true
  name: Perform the query
  when: 'False'
- action: core.python
  desc: Description
  id: S2
  inputs:
    code: 'from dotmap import DotMap

      import json

      filtered_on_alarm = [x for x in context.steps.S1.output.rows if ( x[context.steps.S1.output.columns.index(''status'')]
      == ''alarm'' )]


      check = DotMap()


      check.isAlarm = len(filtered_on_alarm) > 0

      check.details = context.steps.S1.output.rows

      check.name = "1 Amazon EBS snapshots should not be publicly restorable"

      check.severity = "critical"


      print(json.dumps(check.toDict()))'
  name: Format Result
  when: 'False'
- desc: example description delete afterwards
  text: '# 2 VPC default security group should prohibit inbound and outbound traffic'
- text: This control checks that the default security group of a VPC does not allow
    inbound or outbound traffic. It does not check for access restrictions for other
    security groups that are not default, and other VPC configurations.
- action: core.sql
  desc: Description
  id: S3
  inputs:
    sql: " \n select\n  -- Required Columns\n  arn resource,\n  case\n    when ip_permissions\
      \ is null and ip_permissions_egress is null then 'ok'\n    else 'alarm'\n  end\
      \ status,\n  case\n    when ip_permissions is not null and ip_permissions_egress\
      \ is not null\n      then 'Default security group ' || group_id || ' has inbound\
      \ and outbound rules.'\n    when ip_permissions is not null and ip_permissions_egress\
      \ is null\n      then 'Default security group ' || group_id || ' has inbound\
      \ rules.'\n    when ip_permissions is null and ip_permissions_egress is not\
      \ null\n      then 'Default security group ' || group_id || ' has outbound rules.'\n\
      \    else 'Default security group ' || group_id || ' has no inbound or outbound\
      \ rules.'\n  end reason,\n  -- Additional Dimensions\n  region,\n  account_id\n\
      from\n  aws_vpc_security_group\nwhere\n  group_name = 'default';\n"
  name: Perform the query
- action: core.python
  desc: Description
  id: S4
  inputs:
    code: 'from dotmap import DotMap

      import json

      filtered_on_alarm = [x for x in context.steps.S3.output.rows if ( x[context.steps.S3.output.columns.index(''status'')]
      == ''alarm'' )]


      check = DotMap()


      check.isAlarm = len(filtered_on_alarm) > 0

      check.details = context.steps.S3.output.rows

      check.name = "2 VPC default security group should prohibit inbound and outbound
      traffic"

      check.severity = "medium"


      print(json.dumps(check.toDict()))'
  name: Format Result
- desc: example description delete afterwards
  text: '# 3 Unused EC2 security groups should be removed'
- text: This control helps you maintain an accurate asset inventory of needed security
    groups in your cardholder data environment (CDE). It does so by checking that
    security groups are attached to Amazon EC2 instances or to an ENI. A failed finding
    indicates you may have unused Amazon EC2 security groups.
- action: core.sql
  desc: Description
  id: S5
  inputs:
    sql: " \n with associated_sg as (\n  select\n    json_extract(sg.value,'$.GroupId')\
      \ as secgrp_id,\n    json_extract(sg.value,'$.GroupName') as secgrp_name\n \
      \ from\n    aws_ec2_network_interface,\n    json_each(groups) as sg\n)\nselect\n\
      \  -- Required Columns\n  s.arn as resource,\n  case\n    when a.secgrp_id =\
      \ s.group_id then 'ok'\n    else 'alarm'\n  end as status,\n  case\n    when\
      \ a.secgrp_id = s.group_id then s.title || ' is associated.'\n    else s.title\
      \ || ' not associated.'\n  end as reason,\n  -- Additional Dimensions\n  s.region,\n\
      \  s.account_id\nfrom\n  aws_vpc_security_group s\n  left join associated_sg\
      \ a on s.group_id = a.secgrp_id;\n"
  name: Perform the query
- action: core.python
  desc: Description
  id: S6
  inputs:
    code: 'from dotmap import DotMap

      import json

      filtered_on_alarm = [x for x in context.steps.S5.output.rows if ( x[context.steps.S5.output.columns.index(''status'')]
      == ''alarm'' )]


      check = DotMap()


      check.isAlarm = len(filtered_on_alarm) > 0

      check.details = context.steps.S5.output.rows

      check.name = "3 Unused EC2 security groups should be removed"

      check.severity = "low"


      print(json.dumps(check.toDict()))'
  name: Format Result
- desc: example description delete afterwards
  text: '# 4 Unused EC2 EIPs should be removed'
- text: This control checks whether Elastic IP addresses that are allocated to a VPC
    are attached to Amazon EC2 instances or in-use elastic network interfaces (ENIs).
    A failed finding indicates you may have unused Amazon EC2 EIPs. This will help
    you maintain an accurate asset inventory of EIPs in your cardholder data environment
    (CDE).
- action: core.sql
  desc: Description
  id: S7
  inputs:
    sql: " \n select\n  -- Required Columns\n  'arn:' || partition || ':ec2:' || region\
      \ || ':' || account_id || ':eip/' || allocation_id as resource,\n  case\n  \
      \  when association_id is null then 'alarm'\n    else 'ok'\n  end status,\n\
      \  case\n    when association_id is null then title || ' is not associated with\
      \ any resource.'\n    else title || ' is associated with a resource.'\n  end\
      \ reason,\n  -- Additional Dimensions\n  region,\n  account_id\nfrom\n  aws_vpc_eip;"
  name: Perform the query
- action: core.python
  desc: Description
  id: S8
  inputs:
    code: 'from dotmap import DotMap

      import json

      filtered_on_alarm = [x for x in context.steps.S7.output.rows if ( x[context.steps.S7.output.columns.index(''status'')]
      == ''alarm'' )]


      check = DotMap()


      check.isAlarm = len(filtered_on_alarm) > 0

      check.details = context.steps.S7.output.rows

      check.name = "4 Unused EC2 EIPs should be removed"

      check.severity = "low"


      print(json.dumps(check.toDict()))'
  name: Format Result
- desc: example description delete afterwards
  text: '# 5 Security groups should not allow ingress from 0.0.0.0/0 to port 22'
- text: This control checks whether security groups in use disallow unrestricted incoming
    SSH traffic. It does not evaluate outbound traffic. Note that security groups
    are stateful. If you send a request from your instance, the response traffic for
    that request is allowed to flow in regardless of inbound security group rules.
    Responses to allowed inbound traffic are allowed to flow out regardless of outbound
    rules.
- action: core.sql
  desc: Description
  id: S9
  inputs:
    sql: " \n with bad_rules as (\n  select\n    group_id,\n    count(*) as num_bad_rules\n\
      \  from\n    aws_vpc_security_group_rule\n  where\n    type = 'ingress'\n  \
      \  and (\n      cidr_ip = '0.0.0.0/0'\n      or cidr_ipv6 = '::/0'\n    )\n\
      \    and (\n        ( ip_protocol = '-1'      -- all traffic\n        and from_port\
      \ is null\n        )\n        or (\n            from_port >= 22\n          \
      \  and to_port <= 22\n        )\n        or (\n            from_port >= 3389\n\
      \            and to_port <= 3389\n        )\n    )\n  group by\n    group_id\n\
      )\nselect\n  -- Required Columns\n  arn as resource,\n  case\n    when bad_rules.group_id\
      \ is null then 'ok'\n    else 'alarm'\n  end as status,\n  case\n    when bad_rules.group_id\
      \ is null then sg.group_id || ' does not allow ingress to port 22 or 3389 from\
      \ 0.0.0.0/0 or ::/0.'\n    else  sg.group_id || ' contains ' || bad_rules.num_bad_rules\
      \ || ' rule(s) that allow ingress to port 22 or 3389 from 0.0.0.0/0 or ::/0.'\n\
      \  end as reason,\n  -- Additional Dimensions\n  sg.region,\n  sg.account_id\n\
      from\t\n  aws_vpc_security_group as sg\n  left join bad_rules on bad_rules.group_id\
      \ = sg.group_id\n"
  name: Perform the query
- action: core.python
  desc: Description
  id: S10
  inputs:
    code: 'from dotmap import DotMap

      import json

      filtered_on_alarm = [x for x in context.steps.S9.output.rows if ( x[context.steps.S9.output.columns.index(''status'')]
      == ''alarm'' )]


      check = DotMap()


      check.isAlarm = len(filtered_on_alarm) > 0

      check.details = context.steps.S9.output.rows

      check.name = "5 Security groups should not allow ingress from 0.0.0.0/0 to port
      22"

      check.severity = "high"


      print(json.dumps(check.toDict()))'
  name: Format Result
- desc: example description delete afterwards
  text: '#6 VPC flow logging should be enabled in all VPCs - Not implemented'
- text: This control checks whether VPC flow logs are found and enabled for VPCs.
    The traffic type is set to REJECT. With VPC Flow Logs, you can capture information
    about the IP address traffic to and from network interfaces in your VPC. After
    you create a flow log, you can use CloudWatch Logs to view and retrieve the log
    data. Security Hub recommends that you enable flow logging for packet rejects
    for VPCs. Flow logs provide visibility into network traffic that traverses the
    VPC. They can detect anomalous traffic and provide insight into security workflows.
    By default, the record includes values for the different components of the IP
    address flow, including the source, destination, and protocol.
- action: core.sql
  desc: Description
  id: S11
  inputs:
    sql: Select * from true
  name: Perform the query
  when: 'False'
- action: core.python
  desc: Description
  id: S12
  inputs:
    code: 'from dotmap import DotMap

      import json

      filtered_on_alarm = [x for x in context.steps.S11.output.rows if ( x[context.steps.S11.output.columns.index(''status'')]
      == ''alarm'' )]


      check = DotMap()


      check.isAlarm = len(filtered_on_alarm) > 0

      check.details = context.steps.S11.output.rows

      check.name = "6 VPC flow logging should be enabled in all VPCs"

      check.severity = "medium"


      print(json.dumps(check.toDict()))'
  name: Format Result
  when: 'False'
- desc: ' '
  text: '# Send Report to communication channel'
- action: core.python
  desc: Description
  id: FormatResult
  inputs:
    code: "from dotmap import DotMap\nfrom datetime import date\nimport json\n\ntoday\
      \ = \"*\" + str(date.today()) +\"*\"\n\nmessage_blocks = []\nexecution_url =\
      \ context.server_environment_url + \"/workspace/\" + context.workspace_id +\
      \ \"/playbooks/library/playbook?id=\" + context.playbook_id + \"&execution=\"\
      \ + context.execution_id \nheader = {\"type\": \"header\", \"text\": {\"type\"\
      : \"plain_text\",\"text\": \":speaker:  pci_v321_ec2  :speaker:\"}}\ncontext_section\
      \ = {\"type\":\"context\",\"elements\":[{\"text\": today+\" |  pci_v321_ec2\
      \ Check results \",\"type\":\"mrkdwn\"}]}\nblink_execution = {\"type\":\"section\"\
      ,\"text\":{\"text\": \":point_right: <\" + execution_url + \"| *Full report\
      \ available in Blink*>\" ,\"type\":\"mrkdwn\"}}\nmessage_blocks.append(header)\n\
      message_blocks.append(context_section)\nmessage_blocks.append(blink_execution)\n\
      \nstep_ids = ['S2', 'S4', 'S6', 'S8', 'S10', 'S12']\nfor id in step_ids:\n \
      \ if context.steps[id].status == 'OK':\n    message_blocks.append({\"type\"\
      :\"divider\"})\n    \n    section = DotMap()\n    section.type = \"section\"\
      \n    section.text = DotMap()\n    section.text.type = \"mrkdwn\"\n    section.text.text\
      \ = \"\"\n    if context.steps[id].output.isAlarm:\n      section.text.text\
      \ +=  \":x: \"\n    else:\n       section.text.text +=  \":white_check_mark:\
      \ \"\n    \n    section.text.text += context.steps[id].output.name[:82] + \"\
      \\n\" if len(context.steps[id].output.name) > 82 else context.steps[id].output.name\n\
      \    \n\n    message_blocks.append(section.toDict().copy())\n\n  \nprint(json.dumps(message_blocks))"
  name: Format Final Result
- action: slack.SendMessage
  connections:
    slack: slack_connection
  id: SendResult
  inputs:
    Blocks: '{{steps.FormatResult.output}}'
    Channel: random
    Text: ''
  name: Send report to clack channel
  when: '{{inputs.send_notif}}'
tags:
- AWS
- Compliance
- pci_v321
- ec2
type: Subflow.playbook
