connections:
  aws: aws_connection
desc: 'This section contains recommendations for configuring Lambda resources and
  options.

  '
inputs:
  send_notif:
    default: true
    display_name: Send Slack Notification
    required: true
    type: checkbox
name: pci_v321_lambda
outputs:
  S2: '{{steps.S2.output}}'
  S4: '{{steps.S4.output}}'
  check_name: pci_v321_lambda
  execution_url: '{{execution_url}}'
steps:
- desc: example description delete afterwards
  text: '# 1 Lambda functions should prohibit public access'
- text: This control checks whether the Lambda function resource-based policy prohibits
    public access. It does not check for access to the Lambda function by internal
    principals, such as IAM roles. You should ensure that access to the Lambda function
    is restricted to authorized principals only by using least privilege Lambda resource-based
    policies.
- action: core.sql
  desc: Description
  id: S1
  inputs:
    sql: " \n select\n  -- Required Columns\n  arn as resource,\n  case\n    when\
      \ json_extract(policy_std,'$.Statement.Effect') = 'Allow'\n    and (\n     \
      \ json_extract(policy_std,'$.Statement.Prinipal') = '*'\n      or ( json_extract(policy_std,'$.Principal.AWS')\
      \ ) = '*'\n    ) then 'alarm'\n    else 'ok'\n  end status,\n  case\n    when\
      \ policy_std is null then title || ' has no policy.'\n    when json_extract(policy_std,'$.Statement.Effect')\
      \ = 'Allow'\n    and (\n      json_extract(policy_std,'$.Statement.Prinipal')\
      \ = '*'\n      or ( json_extract(policy_std,'$.Principal.AWS') ) = '*'\n   \
      \ ) then title || ' allows public access.'\n    else title || ' does not allow\
      \ public access.'\n  end reason,\n  -- Additional Dimensions\n  region,\n  account_id\n\
      from\n  aws_lambda_function;\n"
  name: Perform the query
- action: core.python
  desc: Description
  id: S2
  inputs:
    code: 'from dotmap import DotMap

      import json

      filtered_on_alarm = [x for x in context.steps.S1.output.rows if ( x[context.steps.S1.output.columns.index(''status'')]
      == ''alarm'' )]


      check = DotMap()


      check.isAlarm = len(filtered_on_alarm) > 0

      check.details = context.steps.S1.output.rows

      check.name = "1 Lambda functions should prohibit public access"

      check.severity = "critical"


      print(json.dumps(check.toDict()))'
  name: Format Result
- desc: example description delete afterwards
  text: '# 2 Lambda functions should be in a VPC'
- text: This control checks whether a Lambda function is in a VPC. It does not evaluate
    the VPC subnet routing configuration to determine public reachability.
- action: core.sql
  desc: Description
  id: S3
  inputs:
    sql: " \n select\n  -- Required Columns\n  arn as resource,\n  case\n    when\
      \ vpc_id is null then 'alarm'\n    else 'ok'\n  end status,\n  case\n    when\
      \ vpc_id is null then title || ' is not in VPC.'\n    else title || ' is in\
      \ VPC ' || vpc_id || '.'\n  end reason,\n  -- Additional Dimensions\n  region,\n\
      \  account_id\nfrom\n  aws_lambda_function;\n"
  name: Perform the query
- action: core.python
  desc: Description
  id: S4
  inputs:
    code: 'from dotmap import DotMap

      import json

      filtered_on_alarm = [x for x in context.steps.S3.output.rows if ( x[context.steps.S3.output.columns.index(''status'')]
      == ''alarm'' )]


      check = DotMap()


      check.isAlarm = len(filtered_on_alarm) > 0

      check.details = context.steps.S3.output.rows

      check.name = "2 Lambda functions should be in a VPC"

      check.severity = "critical"


      print(json.dumps(check.toDict()))'
  name: Format Result
- desc: ' '
  text: '# Send Report to communication channel'
- action: core.python
  desc: Description
  id: FormatResult
  inputs:
    code: "from dotmap import DotMap\nfrom datetime import date\nimport json\n\ntoday\
      \ = \"*\" + str(date.today()) +\"*\"\n\nmessage_blocks = []\nexecution_url =\
      \ context.server_environment_url + \"/workspace/\" + context.workspace_id +\
      \ \"/playbooks/library/playbook?id=\" + context.playbook_id + \"&execution=\"\
      \ + context.execution_id \nheader = {\"type\": \"header\", \"text\": {\"type\"\
      : \"plain_text\",\"text\": \":speaker:  pci_v321_lambda  :speaker:\"}}\ncontext_section\
      \ = {\"type\":\"context\",\"elements\":[{\"text\": today+\" |  pci_v321_lambda\
      \ Check results \",\"type\":\"mrkdwn\"}]}\nblink_execution = {\"type\":\"section\"\
      ,\"text\":{\"text\": \":point_right: <\" + execution_url + \"| *Full report\
      \ available in Blink*>\" ,\"type\":\"mrkdwn\"}}\nmessage_blocks.append(header)\n\
      message_blocks.append(context_section)\nmessage_blocks.append(blink_execution)\n\
      \nstep_ids = ['S2', 'S4']\nfor id in step_ids:\n  if context.steps[id].status\
      \ == 'OK':\n    message_blocks.append({\"type\":\"divider\"})\n    \n    section\
      \ = DotMap()\n    section.type = \"section\"\n    section.text = DotMap()\n\
      \    section.text.type = \"mrkdwn\"\n    section.text.text = \"\"\n    if context.steps[id].output.isAlarm:\n\
      \      section.text.text +=  \":x: \"\n    else:\n       section.text.text +=\
      \  \":white_check_mark: \"\n    \n    section.text.text += context.steps[id].output.name[:82]\
      \ + \"\\n\" if len(context.steps[id].output.name) > 82 else context.steps[id].output.name\n\
      \    \n\n    message_blocks.append(section.toDict().copy())\n\n  \nprint(json.dumps(message_blocks))"
  name: Format Final Result
- action: slack.SendMessage
  connections:
    slack: slack_connection
  id: SendResult
  inputs:
    Blocks: '{{steps.FormatResult.output}}'
    Channel: random
    Text: ''
  name: Send report to clack channel
  when: '{{inputs.send_notif}}'
tags:
- AWS
- Compliance
- pci_v321
- lambda
type: Subflow.playbook
