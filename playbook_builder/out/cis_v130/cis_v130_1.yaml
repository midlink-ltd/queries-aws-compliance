connections:
  aws: aws_connection
desc: ''
name: cis_v130_1
steps:
- desc: example description delete afterwards
  description: Ensure contact email and telephone details for AWS accounts are current
    and map to more than one individual in your organization.
  text: '#1.1 Maintain current contact details'
- action: core.sql
  desc: Description
  id: S1
  inputs:
    sql: " \n select\n  -- Required Columns\n  'arn:' || partition || ':::' || account_id\
      \ as resource,\n  'info' as status,\n  'Manual verification required.' as reason,\n\
      \  -- Additional Dimensions\n  account_id\nfrom\n  aws_account;\n"
  name: Perform the query
- action: core.python
  desc: Description
  id: S2
  inputs:
    code: 'from dotmap import DotMap

      import json

      filtered_on_alarm = [x for x in context.steps.S1.output.rows if ( x[context.steps.S1.output.columns.index(''status'')]
      == ''alarm'' )]


      check = DotMap()


      check.isAlarm = len(filtered_on_alarm) > 0

      check.details = context.steps.S1.output.rows

      check.name = "#1.1 Maintain current contact details"

      check.severity = "DefaultSeverity"


      print(json.dumps(check.toDict()))'
  name: Format Result
- desc: example description delete afterwards
  description: AWS provides customers with the option of specifying the contact information
    for accounts security team. It is recommended that this information be provided.
  text: '#1.2 Ensure security contact information is registered'
- action: core.sql
  desc: Description
  id: S3
  inputs:
    sql: " \n select\n  -- Required Columns\n  'arn:' || partition || ':::' || account_id\
      \ as resource,\n  'info' as status,\n  'Manual verification required.' as reason,\n\
      \  -- Additional Dimensions\n  account_id\nfrom\n  aws_account;\n"
  name: Perform the query
- action: core.python
  desc: Description
  id: S4
  inputs:
    code: 'from dotmap import DotMap

      import json

      filtered_on_alarm = [x for x in context.steps.S3.output.rows if ( x[context.steps.S3.output.columns.index(''status'')]
      == ''alarm'' )]


      check = DotMap()


      check.isAlarm = len(filtered_on_alarm) > 0

      check.details = context.steps.S3.output.rows

      check.name = "#1.2 Ensure security contact information is registered"

      check.severity = "DefaultSeverity"


      print(json.dumps(check.toDict()))'
  name: Format Result
- desc: example description delete afterwards
  description: The AWS support portal allows account owners to establish security
    questions that can be used to authenticate individuals calling AWS customer service
    for support. It is recommended that security questions be established.
  text: '#1.3 Ensure security questions are registered in the AWS account'
- action: core.sql
  desc: Description
  id: S5
  inputs:
    sql: " \n select\n  -- Required Columns\n  'arn:' || partition || ':::' || account_id\
      \ as resource,\n  'info' as status,\n  'Manual verification required.' as reason,\n\
      \  -- Additional Dimensions\n  account_id\nfrom\n  aws_account;\n"
  name: Perform the query
- action: core.python
  desc: Description
  id: S6
  inputs:
    code: 'from dotmap import DotMap

      import json

      filtered_on_alarm = [x for x in context.steps.S5.output.rows if ( x[context.steps.S5.output.columns.index(''status'')]
      == ''alarm'' )]


      check = DotMap()


      check.isAlarm = len(filtered_on_alarm) > 0

      check.details = context.steps.S5.output.rows

      check.name = "#1.3 Ensure security questions are registered in the AWS account"

      check.severity = "DefaultSeverity"


      print(json.dumps(check.toDict()))'
  name: Format Result
- desc: example description delete afterwards
  description: The root user account is the most privileged user in an AWS account.
    AWS Access Keys provide programmatic access to a given AWS account. It is recommended
    that all access keys associated with the root user account be removed.
  text: '#1.4 Ensure no root user account access key exists'
- action: core.sql
  desc: Description
  id: S7
  inputs:
    sql: " \n select\n  -- Required Columns\n  'arn:' || partition || ':::' || account_id\
      \ as resource,\n  case\n    when account_access_keys_present > 0 then 'alarm'\n\
      \    else 'ok'\n  end status,\n  case\n    when account_access_keys_present\
      \ > 0 then 'Root user access keys exist.'\n    else 'No root user access keys\
      \ exist.'\n  end reason,\n  -- Additional Dimensions\n  account_id\nfrom\n \
      \ aws_iam_account_summary;\n"
  name: Perform the query
- action: core.python
  desc: Description
  id: S8
  inputs:
    code: 'from dotmap import DotMap

      import json

      filtered_on_alarm = [x for x in context.steps.S7.output.rows if ( x[context.steps.S7.output.columns.index(''status'')]
      == ''alarm'' )]


      check = DotMap()


      check.isAlarm = len(filtered_on_alarm) > 0

      check.details = context.steps.S7.output.rows

      check.name = "#1.4 Ensure no root user account access key exists"

      check.severity = "DefaultSeverity"


      print(json.dumps(check.toDict()))'
  name: Format Result
- desc: example description delete afterwards
  description: The root user account is the most privileged user in an AWS account.
    Multi-factor Authentication (MFA) adds an extra layer of protection on top of
    a username and password. With MFA enabled, when a user signs in to an AWS website,
    they will be prompted for their username and password as well as for an authentication
    code from their AWS MFA device.
  text: '#1.5 Ensure MFA is enabled for the \root user\ account'
- action: core.sql
  desc: Description
  id: S9
  inputs:
    sql: " \n select\n  -- Required Columns\n  'arn:' || partition || ':::' || account_id\
      \ as resource,\n  case\n    when account_mfa_enabled then 'ok'\n    else 'alarm'\n\
      \  end status,\n  case\n    when account_mfa_enabled then 'MFA enabled for root\
      \ account.'\n    else 'MFA not enabled for root account.'\n  end reason,\n \
      \ -- Additional Dimensions\n  account_id\nfrom\n  aws_iam_account_summary;\n"
  name: Perform the query
- action: core.python
  desc: Description
  id: S10
  inputs:
    code: 'from dotmap import DotMap

      import json

      filtered_on_alarm = [x for x in context.steps.S9.output.rows if ( x[context.steps.S9.output.columns.index(''status'')]
      == ''alarm'' )]


      check = DotMap()


      check.isAlarm = len(filtered_on_alarm) > 0

      check.details = context.steps.S9.output.rows

      check.name = "#1.5 Ensure MFA is enabled for the \root user\ account"

      check.severity = "DefaultSeverity"


      print(json.dumps(check.toDict()))'
  name: Format Result
- desc: example description delete afterwards
  description: The root user account is the most privileged user in an AWS account.
    MFA adds an extra layer of protection on top of a user name and password. With
    MFA enabled, when a user signs in to an AWS website, they will be prompted for
    their user name and password as well as for an authentication code from their
    AWS MFA device. For Level 2, it is recommended that the root user account be protected
    with a hardware MFA.
  text: '#1.6 Ensure hardware MFA is enabled for the \root user\ account'
- action: core.sql
  desc: Description
  id: S11
  inputs:
    sql: " \n select\n  -- Required Columns\n  'arn:' || s.partition || ':::' || s.account_id\
      \ as resource,\n  case\n    when account_mfa_enabled and serial_number is null\
      \ then 'ok'\n    else 'alarm'\n  end status,\n  case\n    when account_mfa_enabled\
      \ = false then  'MFA not enabled for root account.'\n    when serial_number\
      \ is not null then 'Virtual MFA device enabled the root account.'\n    else\
      \ 'Hardware MFA device enabled for root account.'\n  end reason,\n  -- Additional\
      \ Dimensions\n  s.account_id\nfrom\n  aws_iam_account_summary as s\n  left join\
      \ aws_iam_virtual_mfa_device on serial_number = 'arn:' || s.partition || ':iam::'\
      \ || s.account_id || ':mfa/root-account-mfa-device'"
  name: Perform the query
- action: core.python
  desc: Description
  id: S12
  inputs:
    code: 'from dotmap import DotMap

      import json

      filtered_on_alarm = [x for x in context.steps.S11.output.rows if ( x[context.steps.S11.output.columns.index(''status'')]
      == ''alarm'' )]


      check = DotMap()


      check.isAlarm = len(filtered_on_alarm) > 0

      check.details = context.steps.S11.output.rows

      check.name = "#1.6 Ensure hardware MFA is enabled for the \root user\ account"

      check.severity = "DefaultSeverity"


      print(json.dumps(check.toDict()))'
  name: Format Result
- desc: example description delete afterwards
  description: With the creation of an AWS account, a root user is created that cannot
    be disabled or deleted. That user has unrestricted access to and control over
    all resources in the AWS account. It is highly recommended that the use of this
    account be avoided for everyday tasks.
  text: '#1.7 Eliminate use of the root user for administrative and daily tasks'
- action: core.sql
  desc: Description
  id: S13
  inputs:
    sql: " \n select\n  -- Required Columns\n  user_arn as resource,\n  case\n   \
      \ when date(password_last_used) > date('now', '-3 months') then 'alarm'\n  \
      \  when date(access_key_1_last_used_date) <= date('now', '-3 months') then 'alarm'\n\
      \    when date(access_key_2_last_used_date) <= date('now', '-3 months') then\
      \ 'alarm'\n    else 'ok'\n  end as status,\n  case\n    when password_last_used\
      \ is null then 'Root never logged in with password.'\n    else 'Root password\
      \ used ' || password_last_used || ' (' || round(julianday('now') - julianday(password_last_used))\
      \ || ' days).'\n  end ||\n  case\n    when access_key_1_last_used_date is null\
      \ then ' Access Key 1 never used.'\n    else ' Access Key 1 used ' || access_key_1_last_used_date\
      \ || ' (' || round(julianday('now') - julianday(access_key_1_last_used_date))\
      \ || ' days).'\n  end ||\n    case\n    when access_key_2_last_used_date is\
      \ null then ' Access Key 2 never used.'\n    else ' Access Key 2 used ' || access_key_2_last_used_date\
      \ || ' (' || round(julianday('now') - julianday(access_key_2_last_used_date))\
      \ || ' days).'\n  end as reason,\n  account_id\nfrom\n  aws_iam_credential_report\n\
      where\n  user_name = '<root_account>';\n"
  name: Perform the query
- action: core.python
  desc: Description
  id: S14
  inputs:
    code: 'from dotmap import DotMap

      import json

      filtered_on_alarm = [x for x in context.steps.S13.output.rows if ( x[context.steps.S13.output.columns.index(''status'')]
      == ''alarm'' )]


      check = DotMap()


      check.isAlarm = len(filtered_on_alarm) > 0

      check.details = context.steps.S13.output.rows

      check.name = "#1.7 Eliminate use of the root user for administrative and daily
      tasks"

      check.severity = "DefaultSeverity"


      print(json.dumps(check.toDict()))'
  name: Format Result
- desc: example description delete afterwards
  description: Password policies are, in part, used to enforce password complexity
    requirements. IAM password policies can be used to ensure password are at least
    a given length. It is recommended that the password policy require a minimum password
    length 14.
  text: '#1.8 Ensure IAM password policy requires minimum length of 14 or greater'
- action: core.sql
  desc: Description
  id: S15
  inputs:
    sql: " \n select\n  -- Required Columns\n  'arn:' || a.partition || ':::' || a.account_id\
      \ as resource,\n  case\n    when minimum_password_length >= 14 then 'ok'\n \
      \   else 'alarm'\n  end as status,\n  case\n    when minimum_password_length\
      \ is null then 'No password policy set.'\n    else 'Minimum password length\
      \ set to ' || minimum_password_length || '.'\n  end as reason,\n  -- Additional\
      \ Dimensions\n  a.account_id\nfrom\n  aws_account as a\n  left join aws_iam_account_password_policy\
      \ as pol on a.account_id = pol.account_id;\n"
  name: Perform the query
- action: core.python
  desc: Description
  id: S16
  inputs:
    code: 'from dotmap import DotMap

      import json

      filtered_on_alarm = [x for x in context.steps.S15.output.rows if ( x[context.steps.S15.output.columns.index(''status'')]
      == ''alarm'' )]


      check = DotMap()


      check.isAlarm = len(filtered_on_alarm) > 0

      check.details = context.steps.S15.output.rows

      check.name = "#1.8 Ensure IAM password policy requires minimum length of 14
      or greater"

      check.severity = "DefaultSeverity"


      print(json.dumps(check.toDict()))'
  name: Format Result
- desc: example description delete afterwards
  description: IAM password policies can prevent the reuse of a given password by
    the same user. It is recommended that the password policy prevent the reuse of
    passwords.
  text: '#1.9 Ensure IAM password policy prevents password reuse'
- action: core.sql
  desc: Description
  id: S17
  inputs:
    sql: " \n select\n  -- Required Columns\n  'arn:' || a.partition || ':::' || a.account_id\
      \ as resource,\n  case\n    when password_reuse_prevention >= 24 then 'ok'\n\
      \    else 'alarm'\n  end as status,\n  case\n    when minimum_password_length\
      \ is null then 'No password policy set.'\n    when password_reuse_prevention\
      \ is null then 'Password reuse prevention not set.'\n    else 'Password reuse\
      \ prevention set to ' || password_reuse_prevention || '.'\n  end as reason,\n\
      \  -- Additional Dimensions\n  a.account_id\nfrom\n  aws_account as a\n  left\
      \ join aws_iam_account_password_policy as pol on a.account_id = pol.account_id;\n"
  name: Perform the query
- action: core.python
  desc: Description
  id: S18
  inputs:
    code: 'from dotmap import DotMap

      import json

      filtered_on_alarm = [x for x in context.steps.S17.output.rows if ( x[context.steps.S17.output.columns.index(''status'')]
      == ''alarm'' )]


      check = DotMap()


      check.isAlarm = len(filtered_on_alarm) > 0

      check.details = context.steps.S17.output.rows

      check.name = "#1.9 Ensure IAM password policy prevents password reuse"

      check.severity = "DefaultSeverity"


      print(json.dumps(check.toDict()))'
  name: Format Result
- desc: example description delete afterwards
  text: '#1.10 Ensure multi-factor authentication (MFA) is enabled for all IAM users
    that have a console password - Not implemented'
- action: core.sql
  desc: Description
  id: S19
  inputs:
    sql: Select * from true
  name: Perform the query
  when: 'False'
- action: core.python
  desc: Description
  id: S20
  inputs:
    code: 'from dotmap import DotMap

      import json

      filtered_on_alarm = [x for x in context.steps.S19.output.rows if ( x[context.steps.S19.output.columns.index(''status'')]
      == ''alarm'' )]


      check = DotMap()


      check.isAlarm = len(filtered_on_alarm) > 0

      check.details = context.steps.S19.output.rows

      check.name = "#1.10 Ensure multi-factor authentication (MFA) is enabled for
      all IAM users that have a console password - Not implemented"

      check.severity = "DefaultSeverity"


      print(json.dumps(check.toDict()))'
  name: Format Result
  when: 'False'
- desc: example description delete afterwards
  text: '#1.11 Do not setup access keys during initial user setup for all IAM users
    that have a console password - Not implemented'
- action: core.sql
  desc: Description
  id: S21
  inputs:
    sql: Select * from true
  name: Perform the query
  when: 'False'
- action: core.python
  desc: Description
  id: S22
  inputs:
    code: 'from dotmap import DotMap

      import json

      filtered_on_alarm = [x for x in context.steps.S21.output.rows if ( x[context.steps.S21.output.columns.index(''status'')]
      == ''alarm'' )]


      check = DotMap()


      check.isAlarm = len(filtered_on_alarm) > 0

      check.details = context.steps.S21.output.rows

      check.name = "#1.11 Do not setup access keys during initial user setup for all
      IAM users that have a console password - Not implemented"

      check.severity = "DefaultSeverity"


      print(json.dumps(check.toDict()))'
  name: Format Result
  when: 'False'
- desc: example description delete afterwards
  text: '#1.12 Ensure credentials unused for 90 days or greater are disabled - Not
    implemented'
- action: core.sql
  desc: Description
  id: S23
  inputs:
    sql: Select * from true
  name: Perform the query
  when: 'False'
- action: core.python
  desc: Description
  id: S24
  inputs:
    code: 'from dotmap import DotMap

      import json

      filtered_on_alarm = [x for x in context.steps.S23.output.rows if ( x[context.steps.S23.output.columns.index(''status'')]
      == ''alarm'' )]


      check = DotMap()


      check.isAlarm = len(filtered_on_alarm) > 0

      check.details = context.steps.S23.output.rows

      check.name = "#1.12 Ensure credentials unused for 90 days or greater are disabled
      - Not implemented"

      check.severity = "DefaultSeverity"


      print(json.dumps(check.toDict()))'
  name: Format Result
  when: 'False'
- desc: example description delete afterwards
  text: '#1.13 Ensure there is only one active access key available for any single
    IAM user - Not implemented'
- action: core.sql
  desc: Description
  id: S25
  inputs:
    sql: Select * from true
  name: Perform the query
  when: 'False'
- action: core.python
  desc: Description
  id: S26
  inputs:
    code: 'from dotmap import DotMap

      import json

      filtered_on_alarm = [x for x in context.steps.S25.output.rows if ( x[context.steps.S25.output.columns.index(''status'')]
      == ''alarm'' )]


      check = DotMap()


      check.isAlarm = len(filtered_on_alarm) > 0

      check.details = context.steps.S25.output.rows

      check.name = "#1.13 Ensure there is only one active access key available for
      any single IAM user - Not implemented"

      check.severity = "DefaultSeverity"


      print(json.dumps(check.toDict()))'
  name: Format Result
  when: 'False'
- desc: example description delete afterwards
  description: Access keys consist of an access key ID and secret access key, which
    are used to sign programmatic requests that you make to AWS. AWS users need their
    own access keys to make programmatic calls to AWS from the AWS Command Line Interface
    (AWS CLI), Tools for Windows PowerShell, the AWS SDKs, or direct HTTP calls using
    the APIs for individual AWS services. It is recommended that all access keys be
    regularly rotated.
  text: '#1.14 Ensure access keys are rotated every 90 days or less'
- action: core.sql
  desc: Description
  id: S27
  inputs:
    sql: " \n select\n  -- Required Columns\n  'arn:' || partition || ':iam::' ||\
      \ account_id || ':user/' || user_name || '/accesskey/' || access_key_id as resource,\n\
      \  case\n    when create_date <= datetime('now', '-90 day') then 'alarm'\n \
      \   else 'ok'\n  end status,\n  user_name || ' ' || access_key_id || ' created\
      \ ' || date(create_date) ||\n    ' (' || ROUND(JULIANDAY('now') - JULIANDAY(create_date))\
      \ || ' days).'\n  as reason,\n  -- Additional Dimensions\n  account_id\nfrom\n\
      \  aws_iam_access_key;\n"
  name: Perform the query
- action: core.python
  desc: Description
  id: S28
  inputs:
    code: 'from dotmap import DotMap

      import json

      filtered_on_alarm = [x for x in context.steps.S27.output.rows if ( x[context.steps.S27.output.columns.index(''status'')]
      == ''alarm'' )]


      check = DotMap()


      check.isAlarm = len(filtered_on_alarm) > 0

      check.details = context.steps.S27.output.rows

      check.name = "#1.14 Ensure access keys are rotated every 90 days or less"

      check.severity = "DefaultSeverity"


      print(json.dumps(check.toDict()))'
  name: Format Result
- desc: example description delete afterwards
  description: 'IAM users are granted access to services, functions, and data through
    IAM policies. There are three ways to define policies for a user: 1) Edit the
    user policy directly, aka an inline, or user, policy; 2) attach a policy directly
    to a user; 3) add the user to an IAM group that has an attached policy.  Only
    the third implementation is recommended.'
  text: '#1.15 Ensure IAM Users Receive Permissions Only Through Groups'
- action: core.sql
  desc: Description
  id: S29
  inputs:
    sql: " \n select\n  -- Required Columns\n  arn as resource,\n  case\n    when\
      \ inline_policies is null and attached_policy_arns is null then 'ok'\n    else\
      \ 'alarm'\n  end status,\n  name || ' has ' || coalesce(jsonb_array_length(inline_policies),0)\
      \ || ' inline and ' ||\n    coalesce(jsonb_array_length(attached_policy_arns),0)\
      \ || ' directly attached policies.' as reason,\n  -- Additional Dimensions\n\
      \  account_id\nfrom\n  aws_iam_user;\n"
  name: Perform the query
- action: core.python
  desc: Description
  id: S30
  inputs:
    code: 'from dotmap import DotMap

      import json

      filtered_on_alarm = [x for x in context.steps.S29.output.rows if ( x[context.steps.S29.output.columns.index(''status'')]
      == ''alarm'' )]


      check = DotMap()


      check.isAlarm = len(filtered_on_alarm) > 0

      check.details = context.steps.S29.output.rows

      check.name = "#1.15 Ensure IAM Users Receive Permissions Only Through Groups"

      check.severity = "DefaultSeverity"


      print(json.dumps(check.toDict()))'
  name: Format Result
- desc: example description delete afterwards
  text: '#1.16 Ensure IAM policies that allow full \*:*\ administrative privileges
    are not attached - Not implemented'
- action: core.sql
  desc: Description
  id: S31
  inputs:
    sql: Select * from true
  name: Perform the query
  when: 'False'
- action: core.python
  desc: Description
  id: S32
  inputs:
    code: 'from dotmap import DotMap

      import json

      filtered_on_alarm = [x for x in context.steps.S31.output.rows if ( x[context.steps.S31.output.columns.index(''status'')]
      == ''alarm'' )]


      check = DotMap()


      check.isAlarm = len(filtered_on_alarm) > 0

      check.details = context.steps.S31.output.rows

      check.name = "#1.16 Ensure IAM policies that allow full \*:*\ administrative
      privileges are not attached - Not implemented"

      check.severity = "DefaultSeverity"


      print(json.dumps(check.toDict()))'
  name: Format Result
  when: 'False'
- desc: example description delete afterwards
  text: '#1.17 Ensure a support role has been created to manage incidents with AWS
    Support - Not implemented'
- action: core.sql
  desc: Description
  id: S33
  inputs:
    sql: Select * from true
  name: Perform the query
  when: 'False'
- action: core.python
  desc: Description
  id: S34
  inputs:
    code: 'from dotmap import DotMap

      import json

      filtered_on_alarm = [x for x in context.steps.S33.output.rows if ( x[context.steps.S33.output.columns.index(''status'')]
      == ''alarm'' )]


      check = DotMap()


      check.isAlarm = len(filtered_on_alarm) > 0

      check.details = context.steps.S33.output.rows

      check.name = "#1.17 Ensure a support role has been created to manage incidents
      with AWS Support - Not implemented"

      check.severity = "DefaultSeverity"


      print(json.dumps(check.toDict()))'
  name: Format Result
  when: 'False'
- desc: example description delete afterwards
  description: AWS access from within AWS instances can be done by either encoding
    AWS keys into AWS API calls or by assigning the instance to a role which has an
    appropriate permissions policy for the required access. \AWS Access\ means accessing
    the APIs of AWS in order to access AWS resources or manage AWS account resources.
  text: '#1.18 Ensure IAM instance roles are used for AWS resource access from instances'
- action: core.sql
  desc: Description
  id: S35
  inputs:
    sql: " \n select\n  -- Required Columns\n  'arn:' || partition || ':::' || account_id\
      \ as resource,\n  'info' as status,\n  'Manual verification required.' as reason,\n\
      \  -- Additional Dimensions\n  account_id\nfrom\n  aws_account;\n"
  name: Perform the query
- action: core.python
  desc: Description
  id: S36
  inputs:
    code: 'from dotmap import DotMap

      import json

      filtered_on_alarm = [x for x in context.steps.S35.output.rows if ( x[context.steps.S35.output.columns.index(''status'')]
      == ''alarm'' )]


      check = DotMap()


      check.isAlarm = len(filtered_on_alarm) > 0

      check.details = context.steps.S35.output.rows

      check.name = "#1.18 Ensure IAM instance roles are used for AWS resource access
      from instances"

      check.severity = "DefaultSeverity"


      print(json.dumps(check.toDict()))'
  name: Format Result
- desc: example description delete afterwards
  text: '#1.19 Ensure that all the expired SSL/TLS certificates stored in AWS IAM
    are removed - Not implemented'
- action: core.sql
  desc: Description
  id: S37
  inputs:
    sql: Select * from true
  name: Perform the query
  when: 'False'
- action: core.python
  desc: Description
  id: S38
  inputs:
    code: 'from dotmap import DotMap

      import json

      filtered_on_alarm = [x for x in context.steps.S37.output.rows if ( x[context.steps.S37.output.columns.index(''status'')]
      == ''alarm'' )]


      check = DotMap()


      check.isAlarm = len(filtered_on_alarm) > 0

      check.details = context.steps.S37.output.rows

      check.name = "#1.19 Ensure that all the expired SSL/TLS certificates stored
      in AWS IAM are removed - Not implemented"

      check.severity = "DefaultSeverity"


      print(json.dumps(check.toDict()))'
  name: Format Result
  when: 'False'
- desc: example description delete afterwards
  description: Amazon S3 provides Block public access (bucket settings) and Block
    public access (account settings) to help you manage public access to Amazon S3
    resources. By default, S3 buckets and objects are created with public access disabled.
    However, an IAM principle with sufficient S3 permissions can enable public access
    at the bucket and/or object level. While enabled, Block public access (bucket
    settings) prevents an individual bucket, and its contained objects, from becoming
    publicly accessible. Similarly, Block public access (account settings) prevents
    all buckets, and contained objects, from becoming publicly accessible across the
    entire account.
  text: '#1.20 Ensure that S3 Buckets are configured with ''Block public access (bucket
    settings)'''
- action: core.sql
  desc: Description
  id: S39
  inputs:
    sql: " \n select\n  -- Required Columns\n  arn as resource,\n  case\n    when\
      \ (bucket.block_public_acls or s3account.block_public_acls)\n      and (bucket.block_public_policy\
      \ or s3account.block_public_policy)\n      and (bucket.ignore_public_acls or\
      \ s3account.ignore_public_acls)\n      and (bucket.restrict_public_buckets or\
      \ s3account.restrict_public_buckets)\n      then 'ok'\n    else 'alarm'\n  end\
      \ as status,\n  case\n    when (bucket.block_public_acls or s3account.block_public_acls)\n\
      \      and (bucket.block_public_policy or s3account.block_public_policy)\n \
      \     and (bucket.ignore_public_acls or s3account.ignore_public_acls)\n    \
      \  and (bucket.restrict_public_buckets or s3account.restrict_public_buckets)\n\
      \      then name || ' all public access blocks enabled.'\n    else name || '\
      \ not enabled for: ' ||\n      concat_ws(', ',\n        case when not (bucket.block_public_acls\
      \ or s3account.block_public_acls) then 'block_public_acls' end,\n        case\
      \ when not (bucket.block_public_policy or s3account.block_public_policy) then\
      \ 'block_public_policy' end,\n        case when not (bucket.ignore_public_acls\
      \ or s3account.ignore_public_acls) then 'ignore_public_acls' end,\n        case\
      \ when not (bucket.restrict_public_buckets or s3account.restrict_public_buckets)\
      \ then 'restrict_public_buckets' end\n      ) || '.'\n  end as reason,\n  --\
      \ Additional Dimensions\n  bucket.region,\n  bucket.account_id\nfrom\n  aws_s3_bucket\
      \ as bucket,\n  aws_s3_account_settings as s3account;\n"
  name: Perform the query
- action: core.python
  desc: Description
  id: S40
  inputs:
    code: 'from dotmap import DotMap

      import json

      filtered_on_alarm = [x for x in context.steps.S39.output.rows if ( x[context.steps.S39.output.columns.index(''status'')]
      == ''alarm'' )]


      check = DotMap()


      check.isAlarm = len(filtered_on_alarm) > 0

      check.details = context.steps.S39.output.rows

      check.name = "#1.20 Ensure that S3 Buckets are configured with ''Block public
      access (bucket settings)''"

      check.severity = "DefaultSeverity"


      print(json.dumps(check.toDict()))'
  name: Format Result
- desc: example description delete afterwards
  description: Enable IAM Access analyzer for IAM policies about all resources. IAM
    Access Analyzer is a technology introduced at AWS reinvent 2019. After the Analyzer
    is enabled in IAM, scan results are displayed on the console showing the accessible
    resources. Scans show resources that other accounts and federated users can access,
    such as KMS keys and IAM roles. So the results allow you to determine if an unintended
    user is allowed, making it easier for administrators to monitor least privileges
    access.
  text: '#1.21 Ensure that IAM Access analyzer is enabled'
- action: core.sql
  desc: Description
  id: S41
  inputs:
    sql: " \n select\n  -- Required Columns\n  r.region as resource,\n  case\n   \
      \ when aa.arn is not null then 'ok'\n    else 'alarm'\n  end as status,\n  case\n\
      \    when aa.arn is not null then aa.name ||  ' enabled in ' || r.region ||\
      \ '.'\n    else 'Access analyzer not enabled in ' || r.region || '.'\n  end\
      \ as reason,\n  -- Additional Dimensions\n  r.region,\n  r.account_id\nfrom\n\
      \  aws_region as r\n  left join aws_accessanalyzer_analyzer as aa on r.account_id\
      \ = aa.account_id and r.region = aa.region\nwhere\n  r.opt_in_status != 'not-opted-in';\n"
  name: Perform the query
- action: core.python
  desc: Description
  id: S42
  inputs:
    code: 'from dotmap import DotMap

      import json

      filtered_on_alarm = [x for x in context.steps.S41.output.rows if ( x[context.steps.S41.output.columns.index(''status'')]
      == ''alarm'' )]


      check = DotMap()


      check.isAlarm = len(filtered_on_alarm) > 0

      check.details = context.steps.S41.output.rows

      check.name = "#1.21 Ensure that IAM Access analyzer is enabled"

      check.severity = "DefaultSeverity"


      print(json.dumps(check.toDict()))'
  name: Format Result
- desc: example description delete afterwards
  description: In multi-account environments, IAM user centralization facilitates
    greater user control. User access beyond the initial account is then provide via
    role assumption. Centralization of users can be accomplished through federation
    with an external identity provider or through the use of AWS Organizations.
  text: '#1.22 Ensure IAM users are managed centrally via identity federation or AWS
    Organizations for multi-account environments'
- action: core.sql
  desc: Description
  id: S43
  inputs:
    sql: " \n select\n  -- Required Columns\n  'arn:' || partition || ':::' || account_id\
      \ as resource,\n  'info' as status,\n  'Manual verification required.' as reason,\n\
      \  -- Additional Dimensions\n  account_id\nfrom\n  aws_account;\n"
  name: Perform the query
- action: core.python
  desc: Description
  id: S44
  inputs:
    code: 'from dotmap import DotMap

      import json

      filtered_on_alarm = [x for x in context.steps.S43.output.rows if ( x[context.steps.S43.output.columns.index(''status'')]
      == ''alarm'' )]


      check = DotMap()


      check.isAlarm = len(filtered_on_alarm) > 0

      check.details = context.steps.S43.output.rows

      check.name = "#1.22 Ensure IAM users are managed centrally via identity federation
      or AWS Organizations for multi-account environments"

      check.severity = "DefaultSeverity"


      print(json.dumps(check.toDict()))'
  name: Format Result
- action: core.python
  desc: Description
  id: FormatResult
  inputs:
    code: "from dotmap import DotMap\nfrom datetime import date\nimport json\n\ntoday\
      \ = \"*\" + str(date.today()) +\"*\"\n\nmessage_blocks = []\nheader = {\"type\"\
      : \"header\", \"text\": {\"type\": \"plain_text\",\"text\": \":speaker:  cis_v130_1\
      \  :speaker:\"}}\ncontext_section = {\"type\":\"context\",\"elements\":[{\"\
      text\": today+\" |  cis_v130_1 Check results \",\"type\":\"mrkdwn\"}]}\n\nmessage_blocks.append(header)\n\
      message_blocks.append(context_section)\n\nstep_ids = ['S2', 'S4', 'S6', 'S8',\
      \ 'S10', 'S12', 'S14', 'S16', 'S18', 'S20', 'S22', 'S24', 'S26', 'S28', 'S30',\
      \ 'S32', 'S34', 'S36', 'S38', 'S40', 'S42', 'S44']\nfor id in step_ids:\n  if\
      \ context.steps[id].status == 'OK':\n    message_blocks.append({\"type\":\"\
      divider\"})\n    \n    section = DotMap()\n    section.type = \"section\"\n\
      \    section.text = DotMap()\n    section.text.type = \"mrkdwn\"\n    section.text.text\
      \ = \"\"\n    if context.steps[id].output.isAlarm:\n      section.text.text\
      \ +=  \":x: \"\n    else:\n       section.text.text +=  \":white_check_mark:\
      \ \"\n    \n    section.text.text += context.steps[id].output.name[:82] + \"\
      \\n\"\n    \n\n    message_blocks.append(section.toDict().copy())\n\n  \nprint(json.dumps(message_blocks))"
  name: Format Final Result
- action: slack.SendMessage
  connectiuon:
    slack: slack_connection
  id: SendResult
  inputs:
    Blocks: '{{steps.FormatResult.output}}'
    Channel: jon-demo
    Text: ''
  name: Send report to clack channel
tags: []
type: Flow
